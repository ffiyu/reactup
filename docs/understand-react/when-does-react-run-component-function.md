# React 应用的渲染与更新

在本文，我们先站在顶层视角，看看 React 应用渲染与更新的基本流程。

## 渲染入口

一个 React 应用从 `root.render` 开始：

```jsx
import { createRoot } from "react-dom/client";

const domNode = document.getElementById("root");
const root = createRoot(domNode);
root.render(<App />);
```

这段代码很容易理解，获取某个 DOM 节点，并以它为容器，让 React 渲染我们的 React 应用。

## React 应用的更新

应用渲染后，还必须能自我更新，才能动起来。

React 只有一种更新视图的方式，那就是某个组件更新了自身的状态，即执行了 `setState`。然后，React 就会**重新渲染该组件下的整个子树**。

这意味着：

1. 触发状态更新的组件，及其所有后代组件的函数都会重新执行一遍，**不论它们的 props 有没有变化**。
2. 不属于该子树的组件是不会更新的，比如兄弟节点、祖先节点等，即使组件内的数据（非状态）变化了。

因为 React 的基本原则就是“单向数据流”，数据总是从父组件流向子组件。新的状态就是本次更新的数据源，然后顺着“父到子”的数据流，传递到整个子树，所以，有且只有该子树下的组件是应该重新渲染的。

大部分时候，组件状态更新是由事件引起的，比如用户点击、网络请求数据到来等。

## 组件函数执行的 3 种情况

如果聚集到应用中的单个组件，一个组件会在以下 3 种情况下渲染（或更新）：

1. **组件首次挂载时**
2. **组件的状态或依赖的 context 发生变化时**
3. **祖先组件更新时**

2 和 3 都属于组件更新的情况，和上面提到的“状态更新是应用更新的唯一根源”并不矛盾，因为 context 和祖先组件不会自发更新，一定是祖先组件（或该组件）状态更新导致这两个更新的。

组件渲染的过程中，会调用组件函数，所以，但判断某个组件函数为什么会执行时，可以从以上三个原因分析。

## 一些疑惑解答

## Props 与组件的更新的关系

你可能听过类似“props 变化，组件会更新”之类的。不过，props 变化和组件更新没有什么因果关系。

首先，组件的 props 并不会自发更新，一定是父组件更新了才 props 有可能变化，所以说成父组件更新导致子组件更新才对。而且，当父组件更新时，默认情况下不管 props 有没有变化，组件都会更新。

不过，大部分组件在 props 相同时，返回的都是相同的 UI，props 不变时也对组件进行更新确实是一种性能浪费。好在，绝大部分场景下，这点性能损耗都是可接受的，我们不用过分担心。如果真的有明显的性能问题，可以使用 `React.memo` 进行优化。

“Props 改变，组件才会更新”的说法，只适用于用 `React.memo` 包裹过的组件（或继承了`PureComponent`的类组件）。

## 为什么 Props 没变也需要更新？

因为组件可能在更新时，需要执行一些副作用（effect）操作，比如，一个子组件可以需要手动操作父组件预留的某个 DOM 节点，如果父组件更新了，跳过了子组件的更新，可能导致组件异常。所以，没有办法安全地跳过这类更新，必须要我们通过 `React.memo` 或 `PureComponent` 的方式，告诉 React，这个组件是个纯组件，没有副作用，它会跳过不必要的更新。

## 如何理解“按需更新”

首先，代码肯定不是按需执行的。React 更新时，必须调用组件函数，正如[组件函数](./component-function.md)一节中分析的，React 是运行时的 JavaScript，没有能力只执行一个函数内的部分代码，肯定是整个函数重新执行。

其次，所有后代组件都会重新渲染，也不是按需的。

那经常听到的“按需更新”的说法是哪里来的？

更新其实可以分两层。第一层是递归遍历执行所有的后代组件，更新虚拟 DOM，React 把这个过程称为调和（Reconciliation），第二层是根据前后虚拟 DOM 的变化，更新浏览器 DOM，React 把这个过程称为提交（Commit）。本文讨论的是虚拟 DOM 的更新，虚拟 DOM 更新不是按需的，虚拟 DOM 更新不会定会导致浏览器 DOM 更新，浏览器 DOM 的更新是按需的。

## 总结

- 一个 React 应用从 `root.render(<App/>)` 开始。
- 状态更新是应用更新的唯一来源。
- 从状态更新的组件开始，React 会遍历执行整个子树所有组件，更新虚拟 DOM。再对比前后两次虚拟 DOM 的差异，按需更新浏览器 DOM。

<!--
## 性能问题

你可能发现了，父组件更新，所有的后代组件也会一起更新，那性能是不是会有问题？尤其是对那些 props 没有变化的后端组件，执行它们不是浪费吗？

从性能上看这确实是一个浪费。不过，实践证明，在大部分项目下，这种性能损耗不会导致明显的性能问题，不然 React 已经被喷惨了。所以，我们平时不用担心性能问题。

不会引发性能问题，很大一个原因是因为大部分的组件函数都很简单，很快就执行完了。一般的组件函数都是做一些变量的声明、读取、赋值，然后创建并返回 React 元素（JSX）。

这也告诉我们，尽量让组件函数简单，把一些具有较高复杂度的计算放在 `useMemo` 中，避免不必要的计算。

另一个需要关注的是组件的数量，比如：

- 大量使用某个组件。比如，展示大量数据，每个数据对应一个 `<ListItem />`。
- 一个组件有大量的后代组件，而且它自身频繁更新。

这类情况，在每次更新时，都会执行大量的组件函数，容易导致性能问题。可以使用 `React.memo`，当组件的 props 没有变化时，跳过组件的更新。

## `React.memo`

`memo` 可以让我们在更新前，比较新旧两次的 props，决定要不要执行更新。

```js
const MemoizedComponent = memo(SomeComponent, arePropsEqual?)
```

默认情况下，是对每个 prop 做浅比较，如果存在对象结构的 prop，一般使用 `lodash.isEqual` 来做深比较，如果含有函数，还需要注意保证先后两次函数的引用不发生变化，不然即使 `lodash.isEqual` 也会返回 `false`。

`memo` 优化的是第 3 种情况，也就是父组件更新都会导致子组件更新的情况。对于第 1、2 种情况，组件更新是不能也不可避免的。

`memo` 可以提升性能，但是，不要滥用，除非你有理由认为这个组件的频繁更新会导致性能问题。

最后，应该在组件使用的时候，才决定要不要使用 `memo`，不要在组件定义的时候就使用 `memo`。假如你对外提供组件，你不需要在导出之前使用 `memo`。因为你写组件的时候，不知道父组件会不会频繁更新，也不知道组件会不会被大量使用，也不知道如何有效比较两次 props，这些只有使用的时候才知道。

## 总结

- 函数组件会在 3 中情况下执行：
  1. 组件首次挂载时
  2. 组件的状态或依赖的 Context 发生变化时
  3. 父组件重新渲染时
- 父组件更新时，子组件默认都会更新，即使子组件的 props 没有变化。
- 这种冗余的更新，在大部分情况下，不会导致明显的性能问题。
- 为了避免性能问题，记住：
  - 尽量保持组件简单。
  - 在组件内如果有高复杂度的计算，使用 `useMemo`。
  - 对于大量使用的组件，或者更新繁重的组件，可以在必要时使用 `React.memo`。
- 组件自身的状态或依赖的 Context 变化时，组件一定会更新，`React.memo` 不会影响这种情况。 -->
